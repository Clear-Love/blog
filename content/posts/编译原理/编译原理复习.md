---
title: "编译原理"
date: 2023-05-26T06:02:28+08:00
draft: false

toc:
  enable: true
---

#### 教材的图 1-5。

#### Noam Chomsky 的四类文法
   
   几类文法的差别在于对产生式施加不同的限制，分别是：
*  <font color="#ff0000">0 型文法</font> ([短语结构文法](https://www.baike.com/wikiid/1629997799439991160?from=wiki_content&prd=innerlink))(phrase structure grammars)：

   设 G =（VN，VT，P，S），如果它的每个产生式是这样一种结构：α∈(VN∪VT)*　且至少含有一个非终结符，而β∈(VN∪VT)*，则 G 是一个 0 型文法。

*  <font color="#ff0000">1 型文法</font>（上下文有关文法）(context-sensitive grammars)：

   设 G =（VN，VT，P，S）为一文法，若中的每一个产生式均满足|β|>=|α|，仅仅α→ε除外，则文法 G 是 1 型或上下文有关的。

* <font color=" #ff0000 ">2 型文法</font>（[上下文无关文法](https://www.baike.com/wikiid/4801807070024549232?from=wiki_content&prd=innerlink)）(context-free grammars)： 

   设 G =（VN，VT，P，S），若 P 中的每一个产生式满足：α是非终结符，β∈(VN∪VT)*，同时又满足 1 型文法的条件，则此文法称为 2 型的或上下文无关的。

*  <font color="#ff0000">3 型文法</font>（[正规文法](https://www.baike.com/wikiid/1913035081313240466?from=wiki_content&prd=innerlink)）(regular grammars)： 

   设 G =（VN，VT，P，S），若中的每一个产生式的形式都是 A→aB 或 A→a，其中 A 和 B 都是非终结符，a 是终结符，则 G 是 3 型文法或正规文法。

   0 型文法产生的语言称为 0 型语言。

   1 型文法产生的语言称为 1 型语言，也称作上下文有关语言。

   2 型文法产生的语言称为 2 型语言，也称作[上下文无关语言](https://www.baike.com/wikiid/1859083507378455532?from=wiki_content&prd=innerlink)。

   3 型文法产生的语言称为 3 型语言，也称作[正规语言](https://www.baike.com/wikiid/4905508579130313436?from=wiki_content&prd=innerlink)。
   
#### 教材的 3.2.1，进一步地，要能够给制最左或最右推导的语法树。
   
#### 为特定的字符串写出相应的正规式。例如，设字母表为{x, y}，，请写出包含子串 xyx 的所有串
   
#### 构造 NFA，例如，教材第 21 页的例 2.6
   ![](https://pan.lmio.xyz/mio/pic/3ba4bee73d0daf66c8538827035023aa.jpeg)
#### 文法左递归的判断与消除。
   若文法 G 中的非终结符 A，对某个文法符号序列α存在推导 A=>Aα，则称 G 是左递归的。若 G 中有形如 A→Aα的产生式，则称该产生式对 A 直接左递归  
   
   a)<font color=" #ff0000 ">把直接左递归改写为右递归</font>：  
   设有文法产生式：A→Aβ|γ。其中β非空，γ不以 A 打头。  
   可写为：  
   A→γA'  
   A'→βA'|ε  
   一般情况下，假定关于 A 的产生式是：  
	A→Aα1| Aα2 |… |Aαm|β1|β2 |…|βn  
   其中，αi (1≤i≤m) 均不为空，βj (1≤j≤n) 均不以 A 打头。  
   则消除直接左递归后改写为：  
	A→ β1A'| β2 A' |…| βnA'  
	A'→ α1A' | α2A' |…| αmA' |ε  
	
   b)<font color=" #ff0000 ">消除间接左递归</font>：  
   对于间接左递归的消除需要先将间接左递归变为直接左递归，然后再按 a) 清除左递归。  
   例：以文法 G6 为例消除左递归：  
	(1) A→aB  
	(2) A→Bb  
	(3) B→Ac  
	(4) B→d  

   解：用产生式 (1)，(2) 的右部代替产生式 (3) 中的非终结 A 得到左部为 B 的产生式：  
	(1) B→aBc  
	(2) B→Bbc  
	(3) B→d   
	
	
#### 画程序流图。参名教材第 160 页的图 5-3。
   ![](https://pan.lmio.xyz/mio/pic/e388472cfd1c14b0772ccd3679945d5e.jpg)

#### 文法的二义性的证明。

   <font color="#ff0000">二义性</font>：若文法 G 对同一句子产生不止一棵分析树，则称 G 是二义的.
   - 改写二义文法为非二义文法；  
   - 规定二义文法中符号的优先级和结合性，使仅产生一棵分析树。
1. 翻译成四式序列。参考第 133 页的例 4.7
   例 4.7 将下面的语句翻译成四元式：
```c
if(a∧b)
	while (x<y)
		if (m≠n)
			m=n;
		else
   		m=m+1;
else
	while (m>n)
		x=x+y;
```
   ![](https://pan.lmio.xyz/mio/pic/a6a2bf58297375024837053f62f56424.jpg)
```armasm
100(jnz, a, _, 102)
101(j, _, _, 113)
102(jnz, b, _, 104)
103(j, _, _, 113)
104(j<, x, y, 106)
105(j, _, _, 112) 
106(j!=, m, n, 108)
107(j, _, _, 110)
108(=, n, _, m)
109(j, _, _, 111) 
110(+, m, 1, m)
111(j, _, _, 104)
112(j, _, _, 117)
113(j>, m, n, 115)
114(j, _, _, 117)
115(+, x, y, x)
116(j, _, _, 113)
117
```

#### LL（1)，参考教材第 59 页的例 3.8。
   ![](https://pan.lmio.xyz/mio/pic/370b4917f0a17a1b18bec6cd5d33b129.jpg)
   ![](https://pan.lmio.xyz/mio/pic/bfdfc42cee6300cdd3f62115abe8a379.jpg)

#### 自底向上的语法分析文法的基础知识。


LL (1) 分析法是自上而下的分析法。LR (0), LR (1), SLR (1), LALR (1) 是自下而上的分析法。

自上而下:从开始符号出发，根据产生式规则推导给定的句子。用的是推导。

自下而上:从给定的句子规约到文法的开始符号。用的是归约。

下面就主要来讲解他们的不同点， LL (1) 单独讲，其他四种文法分析过程基本有三大步：写出自动机（即 LR (0) 或 LR (1) 项集族，后面都称作自动机） -> 构造文法分析表-> 进行文法分析过程。其中后两步都是类似或者说几乎完全一样的，第一步中的自动机有两种: LR (0) 自动机和 LR (1) 自动机。LR (0) 和 SLR 文法分析用的是 LR (0) 自动机，LR (1) 和 LALR 文法分析用的是 LR (1) 自动机。而 LR (1) 自动机构造方法和 LR (0) 自动机的构造方法相同，只是多增加了向前搜索符号


### 自下而上语法分析

☆自上而下分析采用的是推导;自下而上分析采用的是归约(规范归约—剪句柄—移进/归约分析—SLR(1)分析器).

**（1）自下而上分析的基本方法**

☆<span style="background:#d3f8b6">基本思想</span>：最左归约.

   对于每个输入序列ω：从左到右扫描ω; 从ω开始, 反复用产生式的左部替换产生式的右部 (即当前句型中的句柄)、谋求对ω的匹配, 最终得到文法的开始符号，或者发现一个错误。

☆<span style="background:#d3f8b6">基本概念</span>：

   a)>设αβδ是文法 G 的一个句型，若存在 S=*>αAδ，A=+>β，则称β是句型αβδ相对于 A 的"短语".

> 	特别的，若有 A→β，则称β是句型αβδ相对于产生式 A→β的"直接短语".

>	一个句型的最左直接短语被称为"句柄".

<font color="#ff0000">特征</font>：

   1. 短语：以非终结符为根子树中所有从左到右的叶子；

   2. 直接短语：只有父子关系的子树中所有从左到右排列的叶子（树高为 2）；

   3. 句柄：最左边父子关系树中所有从左到右排列的叶子（句柄是唯一的）

<font color="#ff0000">b)最左归约</font>：若α是文法G的句子且满足下述条件，则称序列αn，αn-1，...，α0是α的一个最左归约。

   1)αn=α

   2)α0=S（S 是 G 的开始符号）

   3) 对任何 i (0<i<=n)，αi-1 是将αi 中句柄替换为相应产生式左部非终结符得到的

☆最左归约的逆过程是一个最右推导，分别称最右推导和最左归约为规范推导和规范归约.

<font color="#ff0000">c）移进-归约分析器</font>

   1. 工作方式：格局与格局变换

   2. 分析表

   3. 驱动器（模拟算法）

   4. SLR 分析表的构造

   5. LR（文法、语言、分析器）

☆<font color=" #ff0000 ">改变格局的动作</font>：
   1. 移进 (shift)：当前剩余输入的下一终结符进栈。
   2. 归约 (reduce)：将栈顶句柄替换为对应非终结符 (最左归约) 
   3. 接受 (accept)：宣告分析成功 
   4. 报错 (error)：发现语法错误，调用错误恢复例程

**(2)LR分析**

<font color="#ff0000">a)LR分析与LR文法</font>  
   LR 分析：允许左递归，但不能有二义

   定义 3.15 若为文法 G 构造的移进-归约分析表中不含多重定义的条目，则称 G 为"LR (k) 文法"，分析器被称为是"LR (k) 分析器"，它所识别的语言被称为"LR (k) 语言"。"L"表示从左到右扫描输入序列，"R"表示逆序的最右推导，"k"表示为确定下一动作向前看的终结符个数，一般情况下 k<=1。当 k=1 时，简称"LR"。

构造SLR(1)分析器

<font color=" #ff0000 ">1 活前缀与 LR (0) 项目</font>

|第 1 步|第 2~N 步|状态|
| - | - | - |
|词法--DFA|ε-closure (S), ε-closure (smove (S, a))|状态集|
|语法--DFA|closure (I), closure (goto (I, x))|项目集|

出现在移进-归约分析器栈中的右句型的前缀，被称为文法 G 的活前缀 (viable prefix).  
LR(0)项目(简称项目)是这样一个产生式，在它右边的某个位置有一个点"."。对于A→ε，它仅有一个项目A→.。  
项目A→α.β显示了分析过程中看到(移进)了产生式的多少。  
β不为空的项目称为可移进项目，β为空的项目称为可归约项目.

<font color=" #ff0000 ">2 拓广文法与识别活前缀的 DFA</font>

G'=G∪{S'→S}  
其中：S'→S 是识别 S 的初态，S'→S.是识别 S 的终态. 目的是使最终构造的 DFA 状态集中具有唯一的初态和终态.  
1. closure (I)：从项目集 I 不经任何文法符号到达的项目全体；

2. goto (I，x)：所有从 I 经文法符号 x 能直接到达的项目全体。

项目[S’→.S]和所有“.”不在产生式右部最左边的项目称为核心项目(kernel items)，

其它“.”在产生式右部最左边的项目(不包括[S’→.S])称为非核心项目(nonkernel items).

核心项目：J=goto(I，X)，S'→.S（作为项目集的代表）

非核心项目：closure(J)-J（特点：可由J某中某项目算得）


β1有效。

当一个项目集中同时存在：

1.A→β1.β2和B→β.：既可移进又可归约，移进/归约冲突

2.A→α.和B→β.：均可指导下一步分析，归约/归约冲突

解决方法：简单向前看一个终结符：

1.移进/归约冲突：若FIRST(β2)∩FOLLOW(B)=Φ，冲突可解决

2.归约/归约冲突：若FOLLOW(A)∩FOLLOW(B)=Φ，冲突可解决

若冲突可以解决，则称文法为SLR(1)文法，构造的分析表为SLR(1)分析表。

SLR(1)文法：简单向前看一个终结符即可解决冲突



   



