---
title: "数据库并发控制"
date: 2023-05-26T06:02:28+08:00
draft: false
tags: ["mysql"]
categories: ["数据库"]
series: ["mysql数据库"]
toc:
  enable: true
---

### 什么是并发

**并发带来的问题**

1. <font color=" #ff0000 ">丢失修改</font> 我修改的东西没生效。比如说我把票价改成 99 元，结果还是原来的 299 元
2. <font color="#ff0000">读脏数据</font> 比如，你要读取数据库中的字段 A、字段 B，你读取时恰巧有其他用户正在更新这 2 个字段，而且是先更新 A、再更新 B,如果那个用户更新一半你就读取了，也就是说更新了 A，正打算要更新 B 但尚未更新时，你就读取了，此时你得到的就是脏数据。
3. <font color=" #ff0000 ">不可重复读</font> 我在一个事务中，连续两次读到的数据不一样。比如我刚开始读到银行余额为 10 元。此时单位突然给发工资 100 到这张卡，那么我第二次读就变成了 110 元。

**解决方法**
1、<font color="#ff0000">排它锁</font>：也叫写锁 X 锁
2、<font color=" #ff0000 ">共享锁</font>：也叫读锁 S 锁

**封锁协议**
1. <font color="#ff0000">一级封锁协议</font> 修改时，必须加 X 锁，直到结束
2. <font color=" #ff0000 ">二级封锁协议</font> 读的时候，加 S 锁，读完就放
3. <font color=" #ff0000 ">三级封锁协议</font> 读的时候，加 S 锁，直到事务结束

一级锁协议：解决*丢失修改*
二级锁协议：解决*读脏数据*
三级锁协议：解决*不可重复度*

### 可串行性
假设多种情况都可以，然后获得结果，
**如果并发执行的结果跟上面的结果里面任意一个一样就可以**

事务 T1：读取 B, A=B+1, 写回 A
事务 T2：读取 A, B=A+1, 写回 B

那么结果假设先 T1，在 T2，那么 A=4, B =3；
假设先 T2, 那么=3, B =4;